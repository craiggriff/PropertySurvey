using System;
using System.Collections;
using Android;
using Android.App;
using Android.Content;
using Android.Content.PM;
using Android.OS;
using Android.Util;
using Android.Views;
using Android.Widget;
using Android.Hardware.Camera2;
using Android.Graphics;
using Android.Hardware.Camera2.Params;
using Android.Media;
using Android.Support.V13.App;
using Android.Support.V4.Content;
using PropertySurvey.Droid.Listeners;
using Java.IO;
using Java.Lang;
using Java.Util;
using Java.Util.Concurrent;
using Boolean = Java.Lang.Boolean;
using Math = Java.Lang.Math;
using Orientation = Android.Content.Res.Orientation;
using System.Linq;
using PropertySurvey;
using System.Collections.Generic;
using System.Xml;
using PropertySurvey.Droid;
using AudioPlayEx.Droid;

namespace PropertySurvey.Droid
{
    
    /*
    // Container Activity must implement this interface
    public interface OnHeadlineSelectedListener
    {
        public void onFin();
    }

    @Override
        public void onAttach(Activity activity)
    {
        super.onAttach(activity);

        // This makes sure that the container activity has implemented
        // the callback interface. If not, it throws an exception
        try
        {
            mCallback = (OnHeadlineSelectedListener)activity;
        }
        catch (ClassCastException e)
        {
            throw new ClassCastException(activity.toString()
                    + " must implement OnHeadlineSelectedListener");
        }
    }
    */


    public class Camera2BasicFragment : Fragment, View.IOnClickListener, FragmentCompat.IOnRequestPermissionsResultCallback
    {
        private static readonly SparseIntArray ORIENTATIONS = new SparseIntArray();
        public static readonly int REQUEST_CAMERA_PERMISSION = 1;
        private static readonly string FRAGMENT_DIALOG = "dialog";

        // Tag for the {@link Log}.
        private static readonly string TAG = "Camera2BasicFragment";

        // Camera state: Showing camera preview.
        public const int STATE_PREVIEW = 0;

        // Camera state: Waiting for the focus to be locked.
        public const int STATE_WAITING_LOCK = 1;

        // Camera state: Waiting for the exposure to be precapture state.
        public const int STATE_WAITING_PRECAPTURE = 2;

        //Camera state: Waiting for the exposure state to be something other than precapture.
        public const int STATE_WAITING_NON_PRECAPTURE = 3;

        public Button num_button; 
        // Camera state: Picture was taken.
        public const int STATE_PICTURE_TAKEN = 4;

        // Max preview width that is guaranteed by Camera2 API
        private static readonly int MAX_PREVIEW_WIDTH = 1440;

        // Max preview height that is guaranteed by Camera2 API
        private static readonly int MAX_PREVIEW_HEIGHT = 720;

        // TextureView.ISurfaceTextureListener handles several lifecycle events on a TextureView
        private Camera2BasicSurfaceTextureListener mSurfaceTextureListener;

        // ID of the current {@link CameraDevice}.
        private string mCameraId;

        // An AutoFitTextureView for camera preview
        private AutoFitTextureView mTextureView;

        // A {@link CameraCaptureSession } for camera preview.
        public CameraCaptureSession mCaptureSession;

        // A reference to the opened CameraDevice
        public CameraDevice mCameraDevice;

        // The size of the camera preview
        private Size mPreviewSize;

        // CameraDevice.StateListener is called when a CameraDevice changes its state
        private CameraStateListener mStateCallback;

        // An additional thread for running tasks that shouldn't block the UI.
        private HandlerThread mBackgroundThread;

        // A {@link Handler} for running tasks in the background.
        public Handler mBackgroundHandler;

        // An {@link ImageReader} that handles still image capture.
        private ImageReader mImageReader;

        // This is the output file for our picture.
        public File mFile;

        // This a callback object for the {@link ImageReader}. "onImageAvailable" will be called when a
        // still image is ready to be saved.
        private ImageAvailableListener mOnImageAvailableListener;

        //{@link CaptureRequest.Builder} for the camera preview
        public CaptureRequest.Builder mPreviewRequestBuilder;

        // {@link CaptureRequest} generated by {@link #mPreviewRequestBuilder}
        public CaptureRequest mPreviewRequest;

        // The current state of camera state for taking pictures.
        public int mState = STATE_PREVIEW;

        // A {@link Semaphore} to prevent the app from exiting before closing the camera.
        public Semaphore mCameraOpenCloseLock = new Semaphore(1);

        // Whether the current camera device supports Flash or not.
        private bool mFlashSupported;

        // Orientation of the camera sensor
        private int mSensorOrientation;

        // A {@link CameraCaptureSession.CaptureCallback} that handles events related to JPEG capture.
        public CameraCaptureListener mCaptureCallback;

        public string full_filename = "";

        private bool bFirstPhoto = true;

        public ISaveAndLoad fileService;

        //@Override
        /*
        public void onFin()
        {
            super.onFin();

            // This makes sure that the container activity has implemented
            // the callback interface. If not, it throws an exception
            try
            {
                mCallback = (OnHeadlineSelectedListener)activity;
            }
            catch (ClassCastException e)
            {
                throw new ClassCastException(activity.toString()
                        + " must implement OnHeadlineSelectedListener");
            }
        }
        */
               
        // Shows a {@link Toast} on the UI thread.
        public void ShowToast(string text)
        {
            
            if (Activity != null)
            {
                Activity.RunOnUiThread(new ShowToastRunnable(Activity.ApplicationContext, text));
            }
            
        }

        public void Fin()
        {
            if (Activity != null)
            {
                Activity.Finish();
            }
        }

        private class ShowToastRunnable : Java.Lang.Object, IRunnable
        {
            private string text;
            private Context context;

            public ShowToastRunnable(Context context, string text)
            {
                this.context = context;
                this.text = text;
            }

            public void Run()
            {
                Toast.MakeText(context, text, ToastLength.Short).Show();
            }
        }

        private static Size ChooseOptimalSize(Size[] choices, int textureViewWidth,
            int textureViewHeight, int maxWidth, int maxHeight, Size aspectRatio)
        {
            // Collect the supported resolutions that are at least as big as the preview Surface
            var bigEnough = new List<Size>();
            // Collect the supported resolutions that are smaller than the preview Surface
            var notBigEnough = new List<Size>();
            int w = aspectRatio.Width;
            int h = aspectRatio.Height;

            for (var i = 0; i < choices.Length; i++)
            {
                Size option = choices[i];
                if ((option.Width <= maxWidth) && (option.Height <= maxHeight) &&
                       option.Height == option.Width * h / w)
                {
                    if (option.Width >= textureViewWidth &&
                        option.Height >= textureViewHeight)
                    {
                        bigEnough.Add(option);
                    }
                    else
                    {
                        notBigEnough.Add(option);
                    }
                }
            }

            // Pick the smallest of those big enough. If there is no one big enough, pick the
            // largest of those not big enough.
            if (bigEnough.Count > 0)
            {
                return (Size)Collections.Min(bigEnough, new CompareSizesByArea());
            }
            else if (notBigEnough.Count > 0)
            {
                return (Size)Collections.Max(notBigEnough, new CompareSizesByArea());
            }
            else
            {
                Log.Error(TAG, "Couldn't find any suitable preview size");
                return choices[0];
            }
        }

        public static Camera2BasicFragment NewInstance()
        {
            return new Camera2BasicFragment();
        }

        public override void OnCreate(Bundle savedInstanceState)
        {
            base.OnCreate(savedInstanceState);
            mStateCallback = new CameraStateListener() { owner = this };
            mSurfaceTextureListener = new Camera2BasicSurfaceTextureListener(this);

            // fill ORIENTATIONS list
            ORIENTATIONS.Append((int)SurfaceOrientation.Rotation0, 90);
            ORIENTATIONS.Append((int)SurfaceOrientation.Rotation90, 0);
            ORIENTATIONS.Append((int)SurfaceOrientation.Rotation180, 270);
            ORIENTATIONS.Append((int)SurfaceOrientation.Rotation270, 180);

            fileService = new SaveAndLoad_Android();
        }

        public override View OnCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
        {
            
            return inflater.Inflate(Resource.Layout.fragment_camera2_basic, container, false);
        }

        public override void OnViewCreated(View view, Bundle savedInstanceState)
        {
            mTextureView = (AutoFitTextureView)view.FindViewById(Resource.Id.texture);
            //View v = view.FindViewById(Resource.Id.picture);
            
            view.FindViewById(Resource.Id.texture).SetOnClickListener(this);

            var imageView = view.FindViewById<ImageView>(Resource.Id.overlay);
            //imageView.set
            if (imageView != null)
            {
                switch (App.CurrentApp.CurrentItem)
                {
                    case "deliveryvan":
                        switch (App.CurrentApp.current_van_picture)
                        {
                            case 1: imageView.SetImageResource(Resource.Drawable.hgv_pas); break;
                            case 2: imageView.SetImageResource(Resource.Drawable.hgv_drv); break;
                            case 3: imageView.SetImageResource(Resource.Drawable.hgv_fnt); break;
                            case 4: imageView.SetImageResource(Resource.Drawable.hgv_bak); break;
                        }
                        break;
                    case "delivery":
                        switch (App.CurrentApp.current_van_picture)
                        {
                            case 1: imageView.SetImageResource(Resource.Drawable.hgv_pas); break;
                            case 2: imageView.SetImageResource(Resource.Drawable.hgv_drv); break;
                            case 3: imageView.SetImageResource(Resource.Drawable.hgv_fnt); break;
                            case 4: imageView.SetImageResource(Resource.Drawable.hgv_bak); break;
                        }
                        break;
                    case "van":
                        switch (App.CurrentApp.current_van_picture)
                        {
                            case 1: imageView.SetImageResource(Resource.Drawable.van1); break;
                            case 2: imageView.SetImageResource(Resource.Drawable.van2); break;
                            case 3: imageView.SetImageResource(Resource.Drawable.van3); break;
                            case 4: imageView.SetImageResource(Resource.Drawable.van4); break;
                        }
                        break;
                    case "car":
                        switch (App.CurrentApp.current_van_picture)
                        {
                            case 1: imageView.SetImageResource(Resource.Drawable.car_pas); break;
                            case 2: imageView.SetImageResource(Resource.Drawable.car_drv); break;
                            case 3: imageView.SetImageResource(Resource.Drawable.car_fnt); break;
                            case 4: imageView.SetImageResource(Resource.Drawable.car_bak); break;
                        }
                        break;
                }
            }


            


            //view.FindViewById(Resource.Id.p1).
            //int resImage = Resources.GetIdentifier(imgName, "drawable", PackageName);
            //view.FindViewById<ImageView>(Resource.Id.van_siloet).SetImageResource(Resource.Drawable.images);

            //int resourceId = (int)typeof(Resource.Drawable).GetField("van_siloet").GetValue(null);

            //view.FindViewById(Resource.Id.van_siloet).SetImageResource(Resource.Drawable.images);

            //view.FindViewById(Resource.Id.van_siloet).im
            //int resImage = Resources.GetIdentifier(imgName, "drawable", PackageName);
            //myTextView.setImageResource(resImage);

            //num_button = (Button)view.FindViewById(Resource.Id.p1);//.FindViewById(R.id.Player1);
            //but.Text = App.net.photos_taken.ToString() + "/" + App.net.photos_required.ToString();

            //view.FindViewById(Resource.Id.info).SetOnClickListener(this);
            //view.FindViewById(Resource.Id.p1)
            /*
            if (App.net.current_line_state == 3)
            {
                view.FindViewById(Resource.Id.p1).Visibility = ViewStates.Invisible;
            }
            else
            {
                view.FindViewById(Resource.Id.p1).Visibility = ViewStates.Visible;
            }
            */
        }

        public override void OnActivityCreated(Bundle savedInstanceState)
        {
            base.OnActivityCreated(savedInstanceState);
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
            var rand_strn = new string(
                    Enumerable.Repeat(chars, 20)
                              .Select(s => s[App.net.random.Next(s.Length)])
                              .ToArray());

            //mFile = new File(Activity.GetExternalFilesDir(null), "pic2.jpg");
            //mCaptureCallback = new CameraCaptureListener(this);
            // mOnImageAvailableListener = new ImageAvailableListener(this, mFile);

            mFile = new File(fileService.CreatePathToFile("Photos/" + App.net.photo_fname));
            //mFile = new File(Activity.GetExternalFilesDir(null), App.net.photo_fname);
            mCaptureCallback = new CameraCaptureListener(this);
            mOnImageAvailableListener = new ImageAvailableListener(this, mFile);

            mOnImageAvailableListener.UpdateFileName(mFile.ToString());

        }

        public override void OnResume()
        {
            base.OnResume();
            StartBackgroundThread();

            if (mTextureView.IsAvailable)
            {
                OpenCamera(mTextureView.Width, mTextureView.Height);
            }
            else
            {
                mTextureView.SurfaceTextureListener = mSurfaceTextureListener;
            }
        }

        public override void OnPause()
        {
            CloseCamera();
            StopBackgroundThread();
            base.OnPause();
        }

        private void RequestCameraPermission()
        {
            if (FragmentCompat.ShouldShowRequestPermissionRationale(this, Manifest.Permission.Camera))
            {
                new ConfirmationDialog().Show(ChildFragmentManager, FRAGMENT_DIALOG);
            }
            else
            {
                FragmentCompat.RequestPermissions(this, new string[] { Manifest.Permission.Camera },
                        REQUEST_CAMERA_PERMISSION);
            }
        }

        public void OnRequestPermissionsResult(int requestCode, string[] permissions, int[] grantResults)
        {
            if (requestCode != REQUEST_CAMERA_PERMISSION)
                return;

            if (grantResults.Length != 1 || grantResults[0] != (int)Permission.Granted)
            {
                ErrorDialog.NewInstance(GetString(Resource.String.request_permission))
                        .Show(ChildFragmentManager, FRAGMENT_DIALOG);
            }
        }

        // Sets up member variables related to camera.
        private void SetUpCameraOutputs(int width, int height)
        {
            var activity = Activity;
            var manager = (CameraManager)activity.GetSystemService(Context.CameraService);
            try
            {
                for (var i = 0; i < manager.GetCameraIdList().Length; i++)
                {
                    var cameraId = manager.GetCameraIdList()[i];
                    CameraCharacteristics characteristics = manager.GetCameraCharacteristics(cameraId);

                    // We don't use a front facing camera in this sample.
                    var facing = (Integer)characteristics.Get(CameraCharacteristics.LensFacing);
                    if (facing != null && facing == (Integer.ValueOf((int)LensFacing.Front)))
                    {
                        continue;
                    }

                    var map = (StreamConfigurationMap)characteristics.Get(CameraCharacteristics.ScalerStreamConfigurationMap);
                    if (map == null)
                    {
                        continue;
                    }

                    //map.GetOutputSizes()

                    //IList<Size> sizes = Arrays.AsList(map.GetOutputSizes((int)ImageFormatType.Jpeg));

                    //Size largest = (Size)Collections.me(Arrays.AsList(map.GetOutputSizes((int)ImageFormatType.Jpeg)),
                    //new CompareSizesByArea());
                    Size[] sizes = map.GetOutputSizes((int)ImageFormatType.Jpeg);

                    if (sizes.Last().Width < sizes.First().Width)
                    {
                        //sizes.Reverse();
                    }
                    // For still image captures, we use the largest available size.
                    //IList<Size> list = Arrays.AsList(map.GetOutputSizes((int)ImageFormatType.Jpeg));
                    //Size size_to_use = new Size(4160, 2080);// = new Size();
                    Size size_to_use = new Size(1920, 1080);// = new Size();
                    foreach (var size in sizes)
                    {
                        if (sizes.Last().Width < sizes.First().Width)
                        {
                            if (size.Width < 1920)
                                break;
                            else
                                size_to_use = size;
                        }
                        else
                        {
                            if (size.Width > 1920)
                                break;
                            else
                                size_to_use = size;
                        }

                    }

                    //Size largest = (Size)Collections.Max(Arrays.AsList(map.GetOutputSizes((int)ImageFormatType.Jpeg)),
                    //    new CompareSizesByArea());
                    mImageReader = ImageReader.NewInstance(size_to_use.Width, size_to_use.Height /*2048, 1152*/, ImageFormatType.Jpeg, /*maxImages*/2);
                    //mImageReader = ImageReader.NewInstance(largest.Width, largest.Height, ImageFormatType.Jpeg, /*maxImages*/2);
                    mImageReader.SetOnImageAvailableListener(mOnImageAvailableListener, mBackgroundHandler);

                    // Find out if we need to swap dimension to get the preview size relative to sensor
                    // coordinate.
                    var displayRotation = activity.WindowManager.DefaultDisplay.Rotation;
                    //noinspection ConstantConditions
                    mSensorOrientation = (int)characteristics.Get(CameraCharacteristics.SensorOrientation);
                    bool swappedDimensions = false;
                    switch (displayRotation)
                    {
                        case SurfaceOrientation.Rotation0:
                        case SurfaceOrientation.Rotation180:
                            if (mSensorOrientation == 90 || mSensorOrientation == 270)
                            {
                                swappedDimensions = true;
                            }
                            break;
                        case SurfaceOrientation.Rotation90:
                        case SurfaceOrientation.Rotation270:
                            if (mSensorOrientation == 0 || mSensorOrientation == 180)
                            {
                                swappedDimensions = true;
                            }
                            break;
                        default:
                            Log.Error(TAG, "Display rotation is invalid: " + displayRotation);
                            break;
                    }

                    Point displaySize = new Point();
                    activity.WindowManager.DefaultDisplay.GetSize(displaySize);
                    var rotatedPreviewWidth = width;
                    var rotatedPreviewHeight = height;
                    var maxPreviewWidth = displaySize.X;
                    var maxPreviewHeight = displaySize.Y;

                    if (swappedDimensions)
                    {
                        rotatedPreviewWidth = height;
                        rotatedPreviewHeight = width;
                        maxPreviewWidth = displaySize.Y;
                        maxPreviewHeight = displaySize.X;
                    }

                    if (maxPreviewWidth > MAX_PREVIEW_WIDTH)
                    {
                        maxPreviewWidth = MAX_PREVIEW_WIDTH;
                    }

                    if (maxPreviewHeight > MAX_PREVIEW_HEIGHT)
                    {
                        maxPreviewHeight = MAX_PREVIEW_HEIGHT;
                    }

                    mPreviewSize = ChooseOptimalSize(map.GetOutputSizes(Class.FromType(typeof(SurfaceTexture))),
                       rotatedPreviewWidth, rotatedPreviewHeight, maxPreviewWidth,
                        maxPreviewHeight, size_to_use);
                    mPreviewSize = new Size(1280,720);

                    //mPreviewSize = GetOptimalSize(map.GetOutputSizes(Class.FromType(typeof(SurfaceTexture))), size_to_use.Width, size_to_use.Height);
                    // We fit the aspect ratio of TextureView to the size of preview we picked.
                    var orientation = Resources.Configuration.Orientation;
                    if (orientation == Orientation.Landscape)
                    {
                        mTextureView.SetAspectRatio(mPreviewSize.Width, mPreviewSize.Height);
                    }
                    else
                    {
                        mTextureView.SetAspectRatio(mPreviewSize.Height, mPreviewSize.Width);
                    }

                    // Check if the flash is supported.
                    var available = (Boolean)characteristics.Get(CameraCharacteristics.FlashInfoAvailable);
                    if (available == null)
                    {
                        mFlashSupported = false;
                    }
                    else
                    {
                        mFlashSupported = (bool)available;
                    }

                    mCameraId = cameraId;
                    return;
                }
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
            catch (NullPointerException e)
            {
                //e.
                // Currently an NPE is thrown when the Camera2API is used but not supported on the
                // device this code runs.
                ErrorDialog.NewInstance(GetString(Resource.String.camera_error)).Show(ChildFragmentManager, FRAGMENT_DIALOG);
            }
        }

        Size GetOptimalSize(IList<Size> sizes, int h, int w)
        {
            double AspectTolerance = 0.1;
            double targetRatio = (double)w / h;

            if (sizes == null)
            {
                return null;
            }

            Size optimalSize = null;
            double minDiff = double.MaxValue;
            int targetHeight = h;

            while (optimalSize == null)
            {
                foreach (Size size in sizes)
                {
                    double ratio = (double)size.Width / size.Height;

                    if (System.Math.Abs(ratio - targetRatio) > AspectTolerance)
                        continue;
                    if (System.Math.Abs(size.Height - targetHeight) < minDiff)
                    {
                        optimalSize = size;
                        minDiff = System.Math.Abs(size.Height - targetHeight);
                    }
                }

                if (optimalSize == null)
                    AspectTolerance += 0.1f;
            }

            return optimalSize;
        }

        // Opens the camera specified by {@link Camera2BasicFragment#mCameraId}.
        public void OpenCamera(int width, int height)
        {
            if (ContextCompat.CheckSelfPermission(Activity, Manifest.Permission.Camera) != Permission.Granted)
            //if (Android.Support.V13.App.ActivityCompat.CheckSelfPermission(Activity, Manifest.Permission.Camera) != Permission.Granted)
            {
                RequestCameraPermission();
                return;
            }
            SetUpCameraOutputs(width, height);
            ConfigureTransform(width, height);
            var activity = Activity;
            var manager = (CameraManager)activity.GetSystemService(Context.CameraService);
            try
            {
                if (!mCameraOpenCloseLock.TryAcquire(2500, TimeUnit.Microseconds))
                {
                    throw new RuntimeException("Time out waiting to lock camera opening.");
                }
                manager.OpenCamera(mCameraId, mStateCallback, mBackgroundHandler);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException("Interrupted while trying to lock camera opening.", e);
            }
        }

        // Closes the current {@link CameraDevice}.
        public void CloseCamera()
        {
            try
            {
                mCameraOpenCloseLock.Acquire();
                if (null != mCaptureSession)
                {
                    mCaptureSession.Close();
                    mCaptureSession = null;
                }
                if (null != mCameraDevice)
                {
                    mCameraDevice.Close();
                    mCameraDevice = null;
                }
                if (null != mImageReader)
                {
                    //mImageReader.Close();
                    //mImageReader = null;
                }
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException("Interrupted while trying to lock camera closing.", e);
            }
            finally
            {
                mCameraOpenCloseLock.Release();
            }
        }

        // Starts a background thread and its {@link Handler}.
        private void StartBackgroundThread()
        {
            mBackgroundThread = new HandlerThread("CameraBackground");
            mBackgroundThread.Start();
            mBackgroundHandler = new Handler(mBackgroundThread.Looper);
        }

        // Stops the background thread and its {@link Handler}.
        private void StopBackgroundThread()
        {
            mBackgroundThread.QuitSafely();
            try
            {
                mBackgroundThread.Join();
                mBackgroundThread = null;
                mBackgroundHandler = null;
            }
            catch (InterruptedException e)
            {
                e.PrintStackTrace();
            }
        }

        // Creates a new {@link CameraCaptureSession} for camera preview.
        public void CreateCameraPreviewSession()
        {
            try
            {
                SurfaceTexture texture = mTextureView.SurfaceTexture;
                if (texture == null)
                {
                    throw new IllegalStateException("texture is null");
                }

                // We configure the size of default buffer to be the size of camera preview we want.
                texture.SetDefaultBufferSize(mPreviewSize.Width, mPreviewSize.Height);

                // This is the output Surface we need to start preview.
                Surface surface = new Surface(texture);

                // We set up a CaptureRequest.Builder with the output Surface.
                mPreviewRequestBuilder = mCameraDevice.CreateCaptureRequest(CameraTemplate.Preview);
                mPreviewRequestBuilder.AddTarget(surface);

                // Here, we create a CameraCaptureSession for camera preview.
                List<Surface> surfaces = new List<Surface>();
                surfaces.Add(surface);
                surfaces.Add(mImageReader.Surface);
                mCameraDevice.CreateCaptureSession(surfaces, new CameraCaptureSessionCallback(this), null);

            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
            //ShowToast(App.net.photos_taken.ToString() + "/" + App.net.photos_required.ToString());
        }

        public static T Cast<T>(Java.Lang.Object obj) where T : class
        {
            var propertyInfo = obj.GetType().GetProperty("Instance");
            return propertyInfo == null ? null : propertyInfo.GetValue(obj, null) as T;
        }

        /**
     * Configures the necessary {@link android.graphics.Matrix} transformation to `mTextureView`.
     * This method should be called after the camera preview size is determined in
     * setUpCameraOutputs and also the size of `mTextureView` is fixed.
     *
     * @param viewWidth  The width of `mTextureView`
     * @param viewHeight The height of `mTextureView`
     */
     /*
        private void configureTransform(int viewWidth, int viewHeight)
        {
            Activity activity = getActivity();
            if (null == mTextureView || null == mPreviewSize || null == activity)
            {
                return;
            }
            int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();
            Matrix matrix = new Matrix();
            RectF viewRect = new RectF(0, 0, viewWidth, viewHeight);
            RectF bufferRect = new RectF(0, 0, mPreviewSize.getHeight(), mPreviewSize.getWidth());
            float centerX = viewRect.centerX();
            float centerY = viewRect.centerY();
            if (Surface.ROTATION_90 == rotation || Surface.ROTATION_270 == rotation)
            {
                bufferRect.offset(centerX - bufferRect.centerX(), centerY - bufferRect.centerY());
                matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);
                float scale = Math.max(
                        (float)viewHeight / mPreviewSize.getHeight(),
                        (float)viewWidth / mPreviewSize.getWidth());
                matrix.postScale(scale, scale, centerX, centerY);
                matrix.postRotate(90 * (rotation - 2), centerX, centerY);
            }
            else if (Surface.ROTATION_180 == rotation)
            {
                matrix.postRotate(180, centerX, centerY);
            }
            mTextureView.setTransform(matrix);
        }
        */


        // Configures the necessary {@link android.graphics.Matrix}
        // transformation to `mTextureView`.
        // This method should be called after the camera preview size is determined in
        // setUpCameraOutputs and also the size of `mTextureView` is fixed.

        public void ConfigureTransform(int viewWidth, int viewHeight)
        {
            Activity activity = Activity;
            if (null == mTextureView || null == mPreviewSize || null == activity)
            {
                return;
            }
            var rotation = (int)activity.WindowManager.DefaultDisplay.Rotation;
            Matrix matrix = new Matrix();
            RectF viewRect = new RectF(0, 0, viewWidth, viewHeight);
            RectF bufferRect = new RectF(0, 0, mPreviewSize.Height, mPreviewSize.Width);
            float centerX = viewRect.CenterX();
            float centerY = viewRect.CenterY();
            if ((int)SurfaceOrientation.Rotation90 == rotation || (int)SurfaceOrientation.Rotation270 == rotation)
            {
                bufferRect.Offset(centerX - bufferRect.CenterX(), centerY - bufferRect.CenterY());
                matrix.SetRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.Fill);
                float scale = Math.Max((float)viewHeight / mPreviewSize.Height, (float)viewWidth / mPreviewSize.Width);
                matrix.PostScale(scale, scale, centerX, centerY);
                matrix.PostRotate(90 * (rotation - 2), centerX, centerY);
            }
            else if ((int)SurfaceOrientation.Rotation180 == rotation)
            {
                matrix.PostRotate(180, centerX, centerY);
            }
            mTextureView.SetTransform(matrix);
        }

        // Initiate a still image capture.
        private void TakePicture()
        {
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
            var rand_strn = new string(
                    Enumerable.Repeat(chars, 20)
                              .Select(s => s[App.net.random.Next(s.Length)])
                              .ToArray());

            //string path1 = System.Environment.GetFolderPath(System.Environment.SpecialFolder.Personal);
            //string path2 = Activity.GetExternalFilesDir(null).Name;

            //mFile = new File(Activity.GetExternalFilesDir(null), "pic3.jpg");
            //mFile.Name = App.net.photo_file_name + App.net.photos_taken.ToString() + rand_strn + ".jpg";
            //mFile.
            //mFile = new File(new File(System.Environment.GetFolderPath(System.Environment.SpecialFolder.Personal)), App.net.photo_file_name + App.net.photos_taken.ToString() + rand_strn + ".jpg");

            //mFile = new File(System.IO.Path.Combine(System.Environment.GetFolderPath(System.Environment.SpecialFolder.Personal), App.net.photo_file_name + App.net.photos_taken.ToString() + rand_strn + ".jpg"));

            //var docsPath = Environment.GetFolderPath(Environment.SpecialFolder.Personal);
            //return Path.Combine(docsPath, filename);
            if (bFirstPhoto == false)
            {
                //File f_to = new File(Activity.GetExternalFilesDir(null), App.net.photo_fname);
                File f_to = new File(fileService.CreatePathToFile("Photos/" + App.net.photo_fname));
                full_filename = f_to.Name.ToString();

                mFile.RenameTo(f_to);

                //mOnImageAvailableListener.UpdateFileName(App.net.photo_file_name + App.net.photos_taken.ToString() + rand_strn + ".jpg");
                mOnImageAvailableListener.UpdateFileName(f_to.ToString());
            }
            else
            {
                bFirstPhoto = false;
            }
            //mFile = new File(Activity.GetExternalFilesDir(null), App.net.photo_file_name + App.net.photos_taken.ToString() + rand_strn + ".jpg");
            //mFile = new File(Activity.GetExternalFilesDir(null), "pic4.jpg");
            //mCaptureCallback = new CameraCaptureListener(this);
            //mOnImageAvailableListener = new ImageAvailableListener(this, mFile);
            ///mOnImageAvailableListener.
            //App.net.current_photo_filename = App.net.photo_file_name + App.net.photos_taken.ToString() + rand_strn + ".jpg";

            if (mCaptureSession != null)
            {
                LockFocus();
            }
        }

        // Lock the focus as the first step for a still image capture.
        private void LockFocus()
        {
            try
            {
                // This is how to tell the camera to lock focus.

                mPreviewRequestBuilder.Set(CaptureRequest.ControlAfTrigger, (int)ControlAFTrigger.Start);

                //mPreviewRequestBuilder.
                // Tell #mCaptureCallback to wait for the lock.
                mState = STATE_WAITING_LOCK;
                mCaptureSession.Capture(mPreviewRequestBuilder.Build(), mCaptureCallback,
                        mBackgroundHandler);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }

        // Run the precapture sequence for capturing a still image. This method should be called when
        // we get a response in {@link #mCaptureCallback} from {@link #lockFocus()}.
        public void RunPrecaptureSequence()
        {
            try
            {
                // This is how to tell the camera to trigger.
                mPreviewRequestBuilder.Set(CaptureRequest.ControlAePrecaptureTrigger, (int)ControlAEPrecaptureTrigger.Start);
                // Tell #mCaptureCallback to wait for the precapture sequence to be set.
                mState = STATE_WAITING_PRECAPTURE;
                mCaptureSession.Capture(mPreviewRequestBuilder.Build(), mCaptureCallback, mBackgroundHandler);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }

        // Capture a still picture. This method should be called when we get a response in
        // {@link #mCaptureCallback} from both {@link #lockFocus()}.
        public void CaptureStillPicture()
        {
            try
            {
                var activity = Activity;
                if (null == activity || null == mCameraDevice)
                {
                    return;
                }
                // This is the CaptureRequest.Builder that we use to take a picture.
                CaptureRequest.Builder captureBuilder = mCameraDevice.CreateCaptureRequest(CameraTemplate.StillCapture);
                captureBuilder.AddTarget(mImageReader.Surface);

                // Use the same AE and AF modes as the preview.
                captureBuilder.Set(CaptureRequest.ControlAfMode, (int)ControlAFMode.ContinuousPicture);
                SetAutoFlash(captureBuilder);

                // Orientation
                int rotation = (int)activity.WindowManager.DefaultDisplay.Rotation; // -90 does not work for some reason
                captureBuilder.Set(CaptureRequest.JpegOrientation, GetOrientation(rotation));

                mCaptureSession.StopRepeating();
                mCaptureSession.Capture(captureBuilder.Build(), new CameraCaptureStillPictureSessionCallback(this), null);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }


        // Retrieves the JPEG orientation from the specified screen rotation.
        private int GetOrientation(int rotation)
        {
            // Sensor orientation is 90 for most devices, or 270 for some devices (eg. Nexus 5X)
            // We have to take that into account and rotate JPEG properly.
            // For devices with orientation of 90, we simply return our mapping from ORIENTATIONS.
            // For devices with orientation of 270, we need to rotate the JPEG 180 degrees.
            return (ORIENTATIONS.Get(rotation) + mSensorOrientation + 270) % 360;
        }

        /*
        private int getJpegOrientation(CameraCharacteristics c, int deviceOrientation)
        {
            if (deviceOrientation == android.view.OrientationEventListener.ORIENTATION_UNKNOWN) return 0;
            int sensorOrientation = c.get(CameraCharacteristics.SENSOR_ORIENTATION);

            // Round device orientation to a multiple of 90
            deviceOrientation = (deviceOrientation + 45) / 90 * 90;

            // Reverse device orientation for front-facing cameras
            boolean facingFront = c.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT;
            if (facingFront) deviceOrientation = -deviceOrientation;

            // Calculate desired JPEG orientation relative to camera orientation to make
            // the image upright relative to the device orientation
            int jpegOrientation = (sensorOrientation + deviceOrientation + 360) % 360;

            return jpegOrientation;
        }
        */

        // Unlock the focus. This method should be called when still image capture sequence is
        // finished.
        public void UnlockFocus()
        {
            try
            {
                // Reset the auto-focus trigger
                mPreviewRequestBuilder.Set(CaptureRequest.ControlAfTrigger, (int)ControlAFTrigger.Cancel);
                SetAutoFlash(mPreviewRequestBuilder);
                if (mCaptureSession != null)
                    mCaptureSession.Capture(mPreviewRequestBuilder.Build(), mCaptureCallback,
                        mBackgroundHandler);
                // After this, the camera will go back to the normal state of preview.
                mState = STATE_PREVIEW;
                if (mCaptureSession != null)
                    mCaptureSession.SetRepeatingRequest(mPreviewRequest, mCaptureCallback,
                        mBackgroundHandler);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }

        public void OnClick(View v)
        {
            switch (v.Id)
            {
                case Resource.Id.texture:
                    if (App.net.TakePhoto() == true)
                    {
                        App.net.FocusSound();
                        TakePicture();
                    }
                    break; 
                    /*
                case Resource.Id.picture:

                    TakePicture();

                    break;
                    */
                    /*
                case Resource.Id.p1:

                    if (App.net.photos_enable_increment == true)
                    {
                        App.net.photos_required++;
                        if (App.net.photos_required > 8)
                            App.net.photos_required = 1;

                        if (App.net.photos_taken >= App.net.photos_required)
                        {
                            //Android.OS.SystemClock.Sleep(1000);
                            //SystemClock.sleep(7000);
                            // timer to make sure it is saved
                            //App.net.pCamera.UpdateFileList();
                            ((CameraActivity)Activity).onFin();
                            //var activity = Activity;
                            //this.Get onFin();
                            //super.onFin();

                        }
                        else
                        {
                            Button but = (Button)v;//.FindViewById(R.id.Player1);
                            but.Text = App.net.photos_taken.ToString() + "/" + App.net.photos_required.ToString();
                        }
                        //ShowToast(App.net.photos_taken.ToString() + "/" + App.net.photos_required.ToString());
                        //but.SetText(string.Format("{0}", App.net.photos_required);
                    }
                    break;*/
                    /*
                case Resource.Id.info:
                    EventHandler<DialogClickEventArgs> nullHandler = null;
                    Activity activity = Activity;
                    if (activity != null)
                    {
                        new AlertDialog.Builder(activity)
                            .SetMessage("Martindales Dispatch")
                            .SetPositiveButton(Android.Resource.String.Ok, nullHandler)
                            .Show();
                    }*/

                    break;
            }
        }

        public void SetAutoFlash(CaptureRequest.Builder requestBuilder)
        {
            if (mFlashSupported)
            {
                requestBuilder.Set(CaptureRequest.ControlAeMode, (int)ControlAEMode.OnAutoFlash);
            }
        }
    }
}